<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on RustCargo - rust语言中文网</title>
    <link>https://www.rustcargo.com/post/</link>
    <description>Recent content in Posts on RustCargo - rust语言中文网</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 20 Nov 2019 12:49:53 +0800</lastBuildDate>
    
	<atom:link href="https://www.rustcargo.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust在线文档</title>
      <link>https://www.rustcargo.com/post/book-docs/</link>
      <pubDate>Mon, 01 Jan 2018 16:01:23 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/book-docs/</guid>
      <description>在线阅读 Rust 程序设计语言（第二版) 通过例子学 Rust Rust 版本指南 Rust 文档工具 kriry技术 awesome-rust-zh</description>
    </item>
    
    <item>
      <title>mut</title>
      <link>https://www.rustcargo.com/post/mut/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/mut/</guid>
      <description>mut 特性中的mut trait Demo{ fn add(a:i32,b:i32) -&amp;gt; i32; } struct ImplIt{} impl Demo for ImplIt{ // 注意: 这里用mut修饰b,但是Demo特性定义中没有mut fn add(a:i32,mut b:i32)-&amp;gt;i32{ b = 100; a+b } } mut与引用 let a = 123;</description>
    </item>
    
    <item>
      <title>Rust 中的类型转换</title>
      <link>https://www.rustcargo.com/post/rust-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/rust-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>1. as 运算符 as 运算符有点像 C 中的强制类型转换，区别在于， 它只能用于原始类型(i32 、i64 、f32 、 f64 、 u8 、 u32 、 char 等类型),并且它是安全的。 例</description>
    </item>
    
    <item>
      <title>一个IO项目：构建命令行程序</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC12%E7%AB%A0-%E4%B8%80%E4%B8%AAio%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC12%E7%AB%A0-%E4%B8%80%E4%B8%AAio%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/</guid>
      <description>第12章 一个IO项目：构建命令行程序 1 接受命令行参数 用std::env::args()方法获取命令行参数，得到的是std::env::Arg</description>
    </item>
    
    <item>
      <title>关于迭代</title>
      <link>https://www.rustcargo.com/post/%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3/</guid>
      <description>关于迭代 for迭代 对集合类型的对象进行for迭代时，对象所有权移动到语句中，迭代得到的对象含有元素的所有权 对集合类型的对象引用进行for迭代</description>
    </item>
    
    <item>
      <title>小技巧</title>
      <link>https://www.rustcargo.com/post/%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>小技巧 关于属性 对整个文件使用某属性： 井号后跟感叹号，然后跟属性说明 常用属性 允许未使用的代码：#[allow(dead_code)] #![allow(dead_code)] const PI : f64</description>
    </item>
    
    <item>
      <title>无畏并发</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC16%E7%AB%A0-%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC16%E7%AB%A0-%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91/</guid>
      <description>第16章 无畏并发 并发（Concurrent）：程序的不同部分相互独立执行 并行（Parallel）：程序不同部分同时执行 1 线程 1.1 基本使用 use std::thread; use</description>
    </item>
    
    <item>
      <title>智能指针</title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>0 简介 引用：最常见的指针类型，不拥有资源的所有权 智能指针：一类表现类似指针的数据结构 通常拥有资源的所有权 通常实现了Deref和Drop特性 常</description>
    </item>
    
    <item>
      <title>智能指针</title>
      <link>https://www.rustcargo.com/post/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>1.Box Box&amp;lt;T&amp;gt;是指向堆中的指针。 fn main() { let box = Box::new(3); println!(&amp;quot;{}&amp;quot;, box); } 在出了指针的作用域之后，指针和它指向的对象都将被释放。 在本例中，box将在m</description>
    </item>
    
    <item>
      <title>更多关于cargo和crates.io</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC14%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8Ecargo%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC14%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8Ecargo%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>第14章 更多关于cargo和crates.io 1 采用发布配置的自定义构建 cargo通常有两种配置：dev和release 可以在cargo.t</description>
    </item>
    
    <item>
      <title>构建多线程Web服务器</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC20%E7%AB%A0-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8Bweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC20%E7%AB%A0-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8Bweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>第20章 构建多线程Web服务器 1 单线程Web服务器 1.1 启动监听、接受连接 use std::net::TcpListener; pub fn step1(){ let listener = TcpListener::bind(&amp;quot;127.0.0.1:7878&amp;quot;).unwrap(); for stream in listener.incoming(){ let stream = stream.unwrap(); println!(&amp;quot;接受一</description>
    </item>
    
    <item>
      <title>枚举与模式匹配</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC06%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC06%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>第06章 枚举与模式匹配 1 枚举 1.1 示例1 enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind: IpAddrKind::V4, address: String::from(&amp;quot;127.0.0.1&amp;quot;), }; let loopback = IpAddr { kind: IpAddrKind::V6, address: String::from(&amp;quot;::1&amp;quot;), }; 1.2 示例2 enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32,</description>
    </item>
    
    <item>
      <title>模块</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC07%E7%AB%A0-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC07%E7%AB%A0-%E6%A8%A1%E5%9D%97/</guid>
      <description>第07章 模块 1 mod与文件系统 1.1 入门 编译以文件为单位进行，无法直接使用定义在其他文件中的常量、变量、函数等 不像C/C++那样有头文件的概念，</description>
    </item>
    
    <item>
      <title>模式匹配</title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>第18章 模式匹配 1 使用模式的场合 1.1 match分支 match表达式必须是穷尽的(exhaustive) match VALUE { PATTERN =&amp;gt; EXPRESSION, PATTERN =&amp;gt; EXPRESSION, PATTERN =&amp;gt; EXPRESSION, } 1.2 if let条件</description>
    </item>
    
    <item>
      <title>泛型、特性与生命周期</title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC10%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC10%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>第10章 泛型、特性与生命周期 0 前言 0.0 重复的代码 fn main() { let number_list = vec![34, 50, 25, 100, 65]; let mut largest = number_list[0]; for number in number_list { if number &amp;gt; largest { largest = number; } } println!(&amp;quot;The largest number is {}&amp;quot;, largest); let number_list = vec![102, 34, 6000, 89, 54, 2, 43,</description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC11%E7%AB%A0-%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC11%E7%AB%A0-%E6%B5%8B%E8%AF%95/</guid>
      <description>第11章 测试 1 测试入门 1.1 增加测试代码 #[cfg(test)] mod tests { #[test] fn exploration() { assert_eq!(2 + 2, 4); } } 1.2 运行测试 用cargo test命令执行测试 每个测试函数在单独的线程中运行，一</description>
    </item>
    
    <item>
      <title>猜猜看</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC02%E7%AB%A0-%E7%8C%9C%E7%8C%9C%E7%9C%8B/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC02%E7%AB%A0-%E7%8C%9C%E7%8C%9C%E7%9C%8B/</guid>
      <description>第02章 猜猜看 /* extern crate 引入外部依赖 use 使得可以用短名称引用外部依赖包中的类型、变量等 */ extern crate rand; use std::io; use std::cmp::Ordering; use rand::Rng; fn main() { println!(&amp;quot;----- 猜数游戏 -----&amp;quot;); // let定义变量,默认</description>
    </item>
    
    <item>
      <title>结构体</title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC05%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC05%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>第05章 结构体 #[allow(unused_variables)] #[allow(dead_code)] fn main() { struct User { username: String, email: String, sign_in_count: u64, active: bool, }; let mut user1 = User { email: String::from(&amp;quot;someone@example.com&amp;quot;), username: String::from(&amp;quot;someusername123&amp;quot;), active: true, sign_in_count: 1, }; user1.email = String::from(&amp;quot;anotheremail@example.com&amp;quot;); } 只能标记结构体变量为mut，不能标记单个字段为mut，</description>
    </item>
    
    <item>
      <title>认识所有权</title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC04%E7%AB%A0-%E8%AE%A4%E8%AF%86%E6%89%80%E6%9C%89%E6%9D%83/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC04%E7%AB%A0-%E8%AE%A4%E8%AF%86%E6%89%80%E6%9C%89%E6%9D%83/</guid>
      <description>1 所有权 1.1 所有权 每个资源（值）都有一个所有者变量 任何时刻一个资源有且只有一个所有者 所有者离开作用域时，资源被释放 1.2 转移所有权 对变量进行赋值、</description>
    </item>
    
    <item>
      <title>通用编程概念</title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC03%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC03%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</guid>
      <description>第03章 通用编程概念 1 常量与变量 1.1 常量 用const定义常量时，必须给出类型 常量名称由大写字母和下划线组成，不遵循此规范会出编译警告：note</description>
    </item>
    
  </channel>
</rss>