<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on RustCargo - rust语言中文网</title>
    <link>https://www.rustcargo.com/post/</link>
    <description>Recent content in Posts on RustCargo - rust语言中文网</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 20 Nov 2019 12:49:53 +0800</lastBuildDate>
    
	<atom:link href="https://www.rustcargo.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust在线文档</title>
      <link>https://www.rustcargo.com/post/book-docs/</link>
      <pubDate>Mon, 01 Jan 2018 16:01:23 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/book-docs/</guid>
      <description>在线阅读 Rust 程序设计语言（第二版)</description>
    </item>
    
    <item>
      <title>错误处理</title>
      <link>https://www.rustcargo.com/post/001_panic_error/</link>
      <pubDate>Wed, 20 Nov 2019 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/001_panic_error/</guid>
      <description>&lt;p&gt;就像大多数编程语言一样，Rust 让程序员使用一种特定方式来处理错误。一般来说，错误处理分为两类途径：异常和返回值。Rust 使用的是返回值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>字符串格式化</title>
      <link>https://www.rustcargo.com/post/002%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Tue, 20 Nov 2018 12:49:53 +0800</pubDate>
      
      <guid>https://www.rustcargo.com/post/002%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>字符串格式化 参考std::fmt模块的文档 模块std::fmt包含对format!宏的运行时支持，而format!宏是print!系列宏的基</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/mut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/mut/</guid>
      <description> mut 特性中的mut trait Demo{ fn add(a:i32,b:i32) -&amp;gt; i32; } struct ImplIt{} impl Demo for ImplIt{ // 注意: 这里用mut修饰b,但是Demo特性定义中没有mut fn add(a:i32,mut b:i32)-&amp;gt;i32{ b = 100; a+b } }  mut与引用 let a = 123; let b = 456; let pi :&amp;amp;i32 = &amp;amp;a; //pi = &amp;amp;b;// 错误: 没有用mut修饰pi,不可以对pi重新赋值 let mut pi : &amp;amp;i32 = &amp;amp;a; pi = &amp;amp;b;// 正确：用mut修饰了pi,可以重新赋值 //*pi = 456;// 错误: 没有对引用类型&amp;amp;i32使用mut,不可以对引用的资源进行修改 let mut a = 123; let pi : &amp;amp;mut i32 = &amp;amp;mut a; //pi = &amp;amp;mut b;// 错误: 没有用mut修饰pi,不可以对pi重新赋值 *pi = 456;// 正确: 对数据类型&amp;amp;i32使用mut,可以对引用的资源进行修改 let mut a = 123; let mut b = 456; let mut pi :&amp;amp;mut i32 = &amp;amp;mut a; pi = &amp;amp;mut b;// 正确: 用mut修饰了pi,可以重新赋值 *pi = 456;// 正确: 对数据类型&amp;amp;i32使用mut,可以对引用的资源进行修改  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/rust-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/rust-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>1. as 运算符 as 运算符有点像 C 中的强制类型转换，区别在于， 它只能用于原始类型(i32 、i64 、f32 、
f64 、 u8 、 u32 、 char 等类型),并且它是安全的。
例
在 Rust 中，不同的数值类型是不能进行隐式转换的，比如：
 let b: i64 = 1i32;  会出现编译错误，提示无法进行类型转换。
error[E0308]: mismatched types --&amp;gt; src\main.rs:2:18 | 2 | let b: i64 = 1i32; | ^^^^ expected i64, found i32 help: change the type of the numeric literal from `i32` to `i64`  这时可以使用as 进行转换。
let b: i64 = 1i32 as i64;   为什么它是安全的？  尝试以下代码：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC04%E7%AB%A0-%E8%AE%A4%E8%AF%86%E6%89%80%E6%9C%89%E6%9D%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC04%E7%AB%A0-%E8%AE%A4%E8%AF%86%E6%89%80%E6%9C%89%E6%9D%83/</guid>
      <description>第04章 认识所有权 1 所有权 1.1 所有权  每个资源（值）都有一个所有者变量 任何时刻一个资源有且只有一个所有者 所有者离开作用域时，资源被释放  1.2 转移所有权 对变量进行赋值、作为参数传入函数、作为返回值从函数返回时，根据变量类型是否实现了Copy特性，有不同的行为
 类型实现了Copy特性：资源被复制，原变量仍然有效 类型没有实现Copy特性：资源的所有权被转移，原变量失效  1.3 Copy特性  所有基础类型（整数、浮点数、字符、布尔量）都实现了Copy特性 无论是编译器自动为基础类型实现Copy特性，还是通过明确声明为自定义类型实现Copy特性，Copy行为都是按比特复制，这个行为不可更改 全部字段都实现了Copy特性时，自定义类型可以实现Copy特性  注意：是可以实现Copy特性，不是实现了Copy特性 在可以实现Copy特性的前提下，可以用两种方法之一实现Copy特性  使用#[derive(Copy)] 使用impl Clone for 类型名{}：不需要提供任何方法   Clone是Copy的基类型，实现Copy的类型，必须也实现Clone 对Copy特性的使用，总是自动的，无法明确要求使用Copy特性  1.4 Clone特性  所有基础类型（整数、浮点数、字符、布尔量）都实现了Clone特性 编译器自动为基础类型实现的Clone行为是按比特复制，这个行为不可改变 可以为任何自定义类型用两种方式之一实现Clone  使用#[derive(Clone)]：要求自定义类型的字段都是实现了Clone的类型 使用impl Clone for 类型名{}：需要提供clone方法：fn clone(&amp;amp;self) -&amp;gt; Self，其行为可以自行定义  对Clone行为的调用，总是手动的，编译器不会自动调用Clone特性  Copy和Clone的对比 相同点  编译器为所有基础类型自动实现了Copy和Clone特性 编译器为所有基础类型实现的Copy/Clone行为都是按比特复制，这个行为不可改变 编译器不会自动为自定义类型实现Copy/Clone特性，必须用两种方法之一明确声明 所有字段都实现了Copy/Clone特性时，可以通过#[derive]为自定义类型实现Copy/Clone特性 通过#[derive]实现Copy/Clone特性时，特性行为都是按比特复制，不需要额外提供方法代码  差异点  只有所有字段都实现了Copy的时候，自定义类型才能够实现Copy，且Copy行为是按比特复制，这个行为不可改变 无论是否所有字段都实现了Clone，都可以为自定义类型实现Clone，且通过impl Clone for 类型实现Clone时，可自定义特性行为 对Copy特性的调用，总是自动的：赋值、作为参数传入函数、作为返回值从函数传出时，  如果类型实现了Copy特性，则自动使用Copy特性 如果类型没有实现Copy特性，则转移所有权  对Clone特性的调用，总是手动的：必须明确地调用clone方法来实现对Clone特性的调用 Clone是Copy的基础特性，实现Copy特性时，必须同时实现Clone特性；反之则不成立：实现Clone特性时，不一定需要实现Copy特性</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC05%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC05%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>第05章 结构体 #[allow(unused_variables)] #[allow(dead_code)] fn main() { struct User { username: String, email: String, sign_in_count: u64, active: bool, }; let mut user1 = User { email: String::from(&amp;quot;someone@example.com&amp;quot;), username: String::from(&amp;quot;someusername123&amp;quot;), active: true, sign_in_count: 1, }; user1.email = String::from(&amp;quot;anotheremail@example.com&amp;quot;); }   只能标记结构体变量为mut，不能标记单个字段为mut，但可以对单个字段使用pub标记  1 变量名与字段名相同时结构体初始化的简略写法 fn build_user(email: String, username: String) -&amp;gt; User { User { email,// 完整写法是: email: email username,// 完整写法是: username: username active: true, sign_in_count: 1, } }  2 结构体更新语法 let user2 = User { email: String::from(&amp;quot;another@example.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC10%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC10%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>第10章 泛型、特性与生命周期 0 前言 0.0 重复的代码 fn main() { let number_list = vec![34, 50, 25, 100, 65]; let mut largest = number_list[0]; for number in number_list { if number &amp;gt; largest { largest = number; } } println!(&amp;quot;The largest number is {}&amp;quot;, largest); let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8]; let mut largest = number_list[0]; for number in number_list { if number &amp;gt; largest { largest = number; } } println!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC13%E7%AB%A0-%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC13%E7%AB%A0-%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>第13章 闭包与迭代器 1 闭包 1.1 闭包与局部函数 fn main(){ // 不能这样定义匿名函数 // let t = fn(t:i32,x:&amp;amp;i32) -&amp;gt; i32 { t + *x }; // 这样(嵌套地)定义局部函数是合法的 fn t(t:i32,x: &amp;amp;i32) -&amp;gt; i32 { t + *x }; assert_eq!(vec![1,2,3].iter().fold(0,t),6); // 但通常使用更简洁的闭包: 通常不指定闭包参数和返回值的类型,而使用自动类型推导 // 而对于函数,不能省略参数和返回值类型 assert_eq!(vec![1,2,3].iter().fold(0,|a,x| a + x),6); }  1.2 闭包可以捕获环境中的变量 fn main() { let x = 4; // 闭包可以使用环境中的变量 x let equal_to_x = |z| z == x; // 不合法: 函数不能使用环境中的变量 x,函数中 x 没有定义 //fn equal_to_x2(z : i32) -&amp;gt; bool { z == x } let y = 4; assert!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>第十五章 智能指针 0 简介  引用：最常见的指针类型，不拥有资源的所有权 智能指针：一类表现类似指针的数据结构  通常拥有资源的所有权 通常实现了Deref和Drop特性 常用的智能指针  Box&amp;lt;T&amp;gt; 用于在堆上分配值 Rc&amp;lt;T&amp;gt; 一个引用计数类型，其数据可以有多个所有者 Ref&amp;lt;T&amp;gt; RefMut&amp;lt;T&amp;gt; 和 RefCell&amp;lt;T&amp;gt;    1 Box&amp;lt;T&amp;gt; Box&amp;lt;T&amp;gt;的用途如下：
 在需要确定大小的上下文中使用大小未知类型（如递归类型），本节讨论这种情况 需要在不复制数据的情况下转移大量数据的所有权时。转移栈上数据的所有权将导致数据复制，对于大量数据 ，复制时间可能很长，这时候可以使用Box&amp;lt;T&amp;gt;：转移Box&amp;lt;T&amp;gt;的所有权只需要复制栈上的数据指针，而不需要复制堆上的数据，所以开销很小。 需要一个实现了特定trait的不确定类型时，这就是第17章将讨论的特性对象（trait object）  示例1：不使用Box&amp;lt;T&amp;gt;创建递归类型  下述代码无法通过编译，提示递归类型List具有无限大小，建议使用box、Rc或者&amp;amp;实现的间接引用 非递归的枚举类型的大小，等于最大字段的大小
enum List{ Cons(i32,List), Nil, } fn main(){ let list = Cons(1,Cons(2,Cons(3,Nil))); }   示例2：使用Box&amp;lt;T&amp;gt;创建递归类型  Box&amp;lt;T&amp;gt;提供了间接存储和堆分配，没有其他特殊功能，所以没有其他智能指针的额外开销 Box&amp;lt;T&amp;gt;实现了Deref特性，所以是智能指针，可以被当做引用对待。 离开作用域时，Box&amp;lt;T&amp;gt;实现的Drop特性中的drop方法被调用，这个方法会清理堆上的数据（栈上的指针被自动清理）。
enum List{ Cons(i32,Box&amp;lt;List&amp;gt;), Nil, } fn main(){ let list = Cons(1,Box::new(Cons(2,Box::new(Cons(3,Box::new(Nil)))))); }   2 Deref特性  引用可看做是指针，可通过解引用运算符 * (星号)访问指针指向的值 Box&amp;lt;T&amp;gt; 实现了Deref特性，可以被当做指针使用，即也可以对Box&amp;lt;T&amp;gt;类型使用解引用运算符</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>第18章 模式匹配 1 使用模式的场合 1.1 match分支  match表达式必须是穷尽的(exhaustive)
match VALUE { PATTERN =&amp;gt; EXPRESSION, PATTERN =&amp;gt; EXPRESSION, PATTERN =&amp;gt; EXPRESSION, }   1.2 if let条件表达式  可组合使用if let/else if/else if let，各分支的条件不一定要相互关联 可以在分支模式中引入仅在分支中有效的覆盖变量 if let表达式对于模式匹配不必是穷尽的，这是与match表达式的差别
fn main() { let favorite_color: Option&amp;lt;&amp;amp;str&amp;gt; = None; let is_tuesday = false; let age: Result&amp;lt;u8, _&amp;gt; = &amp;quot;34&amp;quot;.parse(); if let Some(color) = favorite_color { println!(&amp;quot;Using your favorite color, {}, as the background&amp;quot;, color); } else if is_tuesday { println!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/-%E7%AC%AC19%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/-%E7%AC%AC19%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81/</guid>
      <description>第19章 高级特征 1 不安全的Rust 不安全的Rust的超级力量：
 解引用裸指针 调用不安全的函数/方法 访问/修改可变静态变量 实现不安全特性(trait)  unsafe不会关闭借用检查器或者禁用其他安全检查
1.1 解引用裸指针  裸指针：*const T与*mut T 创建裸指针是安全的；解引用裸指针是不安全的 裸指针与智能指针的差别
 可忽略借用规则：可同时拥有同一个资源的不可变的和可变的裸指针；或者同时有多个指向相同位置的可变裸指针 可以指向无效内存；可以为空 不能实现任何自动清理功能
let mut num = 5; // 可同时有同一个资源的可变和不可变的裸指针 let r1 = &amp;amp;num as *const i32; let r2 = &amp;amp;mut num as *mut i32; // 解引用裸指针的代码是不安全的，必须用unsafe包围 unsafe { println!(&amp;quot;r1 is: {}&amp;quot;, *r1); println!(&amp;quot;r2 is: {}&amp;quot;, *r2); } let address = 0x012345usize; // 裸指针可指向无效位置 let r = address as *const i32;    1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3/</guid>
      <description>关于迭代 for迭代  对集合类型的对象进行for迭代时，对象所有权移动到语句中，迭代得到的对象含有元素的所有权 对集合类型的对象引用进行for迭代时，对象的所有权不移动，迭代得到的是元素的引用  示例1：对集合类型的对象进行for迭代 fn main(){ use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(&amp;quot;Blue&amp;quot;), 10); scores.insert(String::from(&amp;quot;Yellow&amp;quot;), 50); // 1 这里对集合对象进行迭代 for k in scores{ println!(&amp;quot;{:?}&amp;quot;,k); // 得到的 k 是具有所有权的类型,这个解构语句移动了子元素的所有权 let (x,y) = k; println!(&amp;quot;{:?} =&amp;gt; {:?}&amp;quot;,x,y); // 这个语句错误: k 的所有权已经移动(解构到x,y中了),k已经无效 println!(&amp;quot;{:?}&amp;quot;,k); } // 这个语句错误: 前面的for语句移动了scores的所有权,scores已经无效 println!(&amp;quot;{:?}&amp;quot;,scores); }  示例2：对集合类型的对象引用进行for迭代 // 这里对集合对象的引用进行迭代 for k in &amp;amp;scores{ println!(&amp;quot;{:?}&amp;quot;,k); // 得到的 k 是引用类型,没有所有权,下面的解构语句不会移动子元素的所有权 let (x,y) = k; println!(&amp;quot;{:?} =&amp;gt; {:?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>字符串格式化  参考std::fmt模块的文档 模块std::fmt包含对format!宏的运行时支持，而format!宏是print!系列宏的基础  1 入门 format!(&amp;quot;Hello&amp;quot;); // =&amp;gt; &amp;quot;Hello&amp;quot; format!(&amp;quot;Hello, {}!&amp;quot;, &amp;quot;world&amp;quot;); // =&amp;gt; &amp;quot;Hello, world!&amp;quot; format!(&amp;quot;The number is {}&amp;quot;, 1); // =&amp;gt; &amp;quot;The number is 1&amp;quot; format!(&amp;quot;{:?}&amp;quot;, (3, 4)); // =&amp;gt; &amp;quot;(3, 4)&amp;quot; format!(&amp;quot;{value}&amp;quot;, value=4); // =&amp;gt; &amp;quot;4&amp;quot; format!(&amp;quot;{} {}&amp;quot;, 1, 2); // =&amp;gt; &amp;quot;1 2&amp;quot; format!(&amp;quot;{:04}&amp;quot;, 42); // =&amp;gt; &amp;quot;0042&amp;quot; with leading zeros   注意：第一个参数必须是字面字符串，不能是字符串类型的变量 注意：必须使用每个参数至少一次，如果有没有使用的参数，则编译错误  
2 位置参数  默认的{}表示”下一个参数“ 可以用{整数}来指定参数序号（从0开始） 混合使用带序号的，和不带序号的大括号时，不带序号的大括号依次使用各个参数，不影响带序号的各个参数</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E5%AF%86%E7%A0%81%E5%AD%A6/</guid>
      <description>https://blog.csdn.net/s_lisheng/article/details/80567435</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>小技巧 关于属性  对整个文件使用某属性： 井号后跟感叹号，然后跟属性说明 常用属性
 允许未使用的代码：#[allow(dead_code)]
#![allow(dead_code)] const PI : f64 = 3.1415926; pub fn add(x : i32,y : i32) -&amp;gt; i32{ x + y } pub fn sub(x : i32,y : i32) -&amp;gt; i32{ x - y }    crate属性  包属性表示为#![attribute_name(arg1, ...)] 特别地，feature包属性表示为#![feature(参数)]，如#![feature(fnbox)] 包属性需要添加到根文件中  库：就是lib.rs 二进制程序：就是main.rs 集成测试：tests目录中的每个文件 示例：examples目录中的每个文件   进程操作  std::process::abort() std::process::exit() std::process::id() 创建进程：os::process::Command::new(&amp;quot;ls&amp;quot;).spawn().expect(&amp;quot;ls command failed to start&amp;quot;);  输出到标准错误输出  eprintln!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>文件操作  std::fs模块处理文件操作 文件由std::fs::File表示  0 std::fs模块公有方法 pub fn metadata&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;Metadata&amp;gt;;// stat pub fn symlink_metadata&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;Metadata&amp;gt;; pub fn remove_file&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn rename&amp;lt;P: AsRef&amp;lt;Path&amp;gt;, Q: AsRef&amp;lt;Path&amp;gt;&amp;gt;(from: P, to: Q) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn copy&amp;lt;P: AsRef&amp;lt;Path&amp;gt;, Q: AsRef&amp;lt;Path&amp;gt;&amp;gt;(from: P, to: Q) -&amp;gt; io::Result&amp;lt;u64&amp;gt;; pub fn canonicalize&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;PathBuf&amp;gt;; pub fn create_dir&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn create_dir_all&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn remove_dir&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn remove_dir_all&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn read_dir&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;ReadDir&amp;gt;;// walk pub fn set_permissions&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P, perm: Permissions)-&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn hard_link&amp;lt;P: AsRef&amp;lt;Path&amp;gt;, Q: AsRef&amp;lt;Path&amp;gt;&amp;gt;(src: P, dst: Q) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn soft_link&amp;lt;P: AsRef&amp;lt;Path&amp;gt;, Q: AsRef&amp;lt;Path&amp;gt;&amp;gt;(src: P, dst: Q) -&amp;gt; io::Result&amp;lt;()&amp;gt;; pub fn read_link&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;PathBuf&amp;gt;;  1 File的关联方法 pub fn open&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;File&amp;gt;; pub fn create&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;File&amp;gt;;  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>1.Box Box&amp;lt;T&amp;gt;是指向堆中的指针。
fn main() { let box = Box::new(3); println!(&amp;quot;{}&amp;quot;, box); }  在出了指针的作用域之后，指针和它指向的对象都将被释放。
在本例中，box将在main函数之后被释放。
由于Box&amp;lt;T&amp;gt;的大小是确定的(size类型的大小)，所以可以使用Box编写嵌套类型，比如实现链表。
2.Deref trait 实现Deref这个trait可以重载解引用运算符(*)，这样可以把Deref trait当作普通引用。
use std::ops::Deref; fn main() { let b=MyBox::new(12); assert_eq!(*b,12); } struct MyBox&amp;lt;T&amp;gt;(T); impl&amp;lt;T&amp;gt; MyBox&amp;lt;T&amp;gt; { fn new(value: T) -&amp;gt; Self { MyBox(value) } } impl&amp;lt;T&amp;gt; Deref for MyBox&amp;lt;T&amp;gt; { type Target = T; fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Self::Target { &amp;amp;self.0 } }  当调用*b时，本质上是*(b.deref())，这样&amp;amp;引用和Deref引用的形式就统一了。
函数和方法的隐式解引用强制多态 假设我们有一个函数，它需要一个&amp;amp;str类型的参数。
fn print_name(name: &amp;amp;str){ println!(&amp;quot;name:{}&amp;quot;,name); }  改变main中的代码</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC02%E7%AB%A0-%E7%8C%9C%E7%8C%9C%E7%9C%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC02%E7%AB%A0-%E7%8C%9C%E7%8C%9C%E7%9C%8B/</guid>
      <description>第02章 猜猜看 /* extern crate 引入外部依赖 use 使得可以用短名称引用外部依赖包中的类型、变量等 */ extern crate rand; use std::io; use std::cmp::Ordering; use rand::Rng; fn main() { println!(&amp;quot;----- 猜数游戏 -----&amp;quot;); // let定义变量,默认为不可变的(immutable) let secret_number = rand::thread_rng().gen_range(1,101); loop{ println!(&amp;quot;输入猜测值: &amp;quot;); // 用mut明确说明变量值可修改 let mut guess = String::new(); // io::stdin() 返回 Stdin 实例 // read_line() 方法读取一行 // &amp;amp;mut 表示引用可变的变量 // read_line() 的返回值为Result类型,是一个枚举,取值有OK和Err // Result 类型的 expect() 方法在值为 Err 的时候 panic // 导致程序退出 io::stdin().read_line(&amp;amp;mut guess).expect(&amp;quot;读取行失败&amp;quot;); // 允许变量遮盖(shadow)：可再次用let定义同名变量，并且可以改变变量类型 // String 类型的 trim() 方法去除头尾空格 // parse() 解析字符串到数,可返回多种类型,所以需要指定类型 // let mut guess: u32 = match guess.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.rustcargo.com/post/%E7%AC%AC03%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.rustcargo.com/post/%E7%AC%AC03%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</guid>
      <description>第03章 通用编程概念 1 常量与变量 1.1 常量  用const定义常量时，必须给出类型 常量名称由大写字母和下划线组成，不遵循此规范会出编译警告：note: #[warn(non_upper_case_globals)] on by default 可以用#[allow(non_upper_case_globals)]注解关闭警告 可以在全局范围（非函数/方法中）定义常量
#[allow(non_upper_case_globals)] mod a{ pub const pi : f64 = 3.14; } fn main(){ println!(&amp;quot;{}&amp;quot;,a::pi); }   1.2 变量  用let定义变量，通常使用自动类型推导，也可以变量名后加冒号和类型来指定类型 默认是不可变的，可以用mut指定是可变的 对不可变变量重新赋值会出现编译错误 可重复使用let定义同名变量，这就是 变量遮盖(shadow) ,遮盖时可修改变量类型 可以在全局范围定义变量，但是不建议这样使用，因为访问全局范围定义的静态变量时需要使用unsafe，详见第19章《高级特征》的1.3节  2 数据类型 2.1 标量类型 2.1.1 整数  字面整数值的类型默认为i32 字面数值类型中可以使用下划线以增加可读性 Rust 1.26.0 增加了i128和u128类型，由LLVM支持  2.1.2 浮点数  有f32和f64两种类型，字面值的类型默认为f64  2.1.3 布尔型  布尔型bool有两种值：true和false  2.1.4 字符类型  字符类型char的字面值用单引号表示 一个字符类型的值表示一个Unicode字符，可以表示中文  2.</description>
    </item>
    
  </channel>
</rss>